diff --git a/node_modules/@ethereum-waffle/compiler/dist/cjs/compileSolcjs.js b/node_modules/@ethereum-waffle/compiler/dist/cjs/compileSolcjs.js
index 5b6a2db..a210c9f 100644
--- a/node_modules/@ethereum-waffle/compiler/dist/cjs/compileSolcjs.js
+++ b/node_modules/@ethereum-waffle/compiler/dist/cjs/compileSolcjs.js
@@ -51,6 +51,7 @@ function compileSolcjs(config) {
         const solc = await loadCompiler(config);
         const input = compilerInput_1.getCompilerInput(sources, config.compilerOptions, 'Solidity');
         const imports = findImports_1.findImports(sources);
+        // console.log(input); // This shows that the "ast" option DOES make it to the CLI arguments for solcjs
         const output = solc.compile(input, { imports });
         return JSON.parse(output);
     };
diff --git a/node_modules/@ethereum-waffle/compiler/dist/cjs/compilerInput.js b/node_modules/@ethereum-waffle/compiler/dist/cjs/compilerInput.js
index 5c24e5e..12619d6 100644
--- a/node_modules/@ethereum-waffle/compiler/dist/cjs/compilerInput.js
+++ b/node_modules/@ethereum-waffle/compiler/dist/cjs/compilerInput.js
@@ -9,7 +9,7 @@ function getCompilerInput(files, overrides = {}, language) {
         language,
         sources,
         settings: {
-            outputSelection: { '*': { '*': ['abi', 'evm.bytecode', 'evm.deployedBytecode'] } },
+            outputSelection: { '*': {"": ["legacyAST", "ast"],'*': ['abi', 'evm.bytecode', 'evm.deployedBytecode'] } },
             ...overrides
         }
     });
diff --git a/node_modules/@ethereum-waffle/compiler/dist/cjs/saveOutput.js b/node_modules/@ethereum-waffle/compiler/dist/cjs/saveOutput.js
index 602f0ee..aaa5f98 100644
--- a/node_modules/@ethereum-waffle/compiler/dist/cjs/saveOutput.js
+++ b/node_modules/@ethereum-waffle/compiler/dist/cjs/saveOutput.js
@@ -41,10 +41,11 @@ function getMinimalContent(contractJson, config) {
     return JSON.stringify({ abi, bytecode }, null, 2);
 }
 async function saveOutputSingletons(output, config, filesystem = fsOps) {
-    for (const [, file] of Object.entries(output.contracts)) {
+    for (const [source_path, file] of Object.entries(output.contracts)) {
         for (const [contractName, contractJson] of Object.entries(file)) {
             const filePath = path_1.join(config.outputDirectory, `${contractName}.json`);
-            filesystem.writeFile(filePath, getContent(contractJson, config));
+            console.log(output.sources[source_path]);
+            filesystem.writeFile(filePath, getContent(contractJson, output.sources[source_path] ? output.sources[source_path].ast : undefined, source_path, config));
         }
     }
 }
@@ -68,8 +69,11 @@ async function saveOutputCombined(output, config, filesystem = fsOps) {
     output.sourceList = allSources;
     filesystem.writeFile(path_1.join(config.outputDirectory, 'Combined-Json.json'), JSON.stringify(output, null, 2));
 }
-function getContent(contractJson, config) {
+function getContent(contractJson, ast, sourcePath, config) {
     contractJson.bytecode = contractJson.evm.bytecode.object;
+    contractJson.sourcePath = sourcePath;
+    contractJson.ast = ast;
+    console.log('loading sources')
     if (config.outputHumanReadableAbi) {
         contractJson.humanReadableAbi = getHumanReadableAbi_1.getHumanReadableAbi(contractJson.abi);
     }
